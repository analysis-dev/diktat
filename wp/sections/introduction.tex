It is necessary to conform to a specific style of code during software development, otherwise it will lead to difficulties in reading and writing the program. The static analyzer, in turn, has methods for finding and correcting style errors. There are both open source\footnote{PMD: \url{http://pmd.sourceforge.net/}, Rubocop: \url{https://github.com/rubocop-hq/rubocop},
PHPCS: \url{https://github.com/squizlabs/PHP_CodeSniffer}
FindSecBugs: \url{https://find-sec-bugs.github.io/}, ESLint: \url{https://eslint.org/}, Checkstyle: \url{https://checkstyle.sourceforge.io/}.}
(PMD, Rubocop, PHPCS, FindSecBugs, ESLint, Checkstyle, to name a few) and commercial\footnote{IBM Security AppScan: \url{https://www.hcltechsw.com/wps/portal/products/appscan},
PVS-Studio: \url{https://www.viva64.com/en/pvs-studio/},
SonarQube: \url{https://www.sonarqube.org/},
Parasoft: \url{https://www.parasoft.com/}}
(IBM Security AppScan, PVS-Studio, SonarQube, Parasoft) static analyzers
on the market.

Of the tasks solved by static code analysis programs, two main ones can be distinguished: identifying errors
in programs and recommending code formatting. That is, the analyzer allows you to check whether the source
code complies with the accepted coding standard. Also, a static analyzer can be used to determine the
maintainability of a code, which is how easy it is to analyze, modify and adapt a given software.

Functional quality aspects are typically quite susceptible to formal definition
and quantification.
% (\todo: examples!!).
Functional quality is also an essential
requirement in any domain of software development. On the other hand,
maintainability is a lot less straightforward to formally specify or quantify.
%\todo: refs.
Also, in certain applications it appears less important than
functional correctness, although in business domain it is recognized as an
essential property.
% (\todo: ref).
As a result, there are currently a lot more
research and practical tools addressing functional quality aspects of code than
maintainability \citep{Overview_Static_Code_Analysis_in_Software_Development}.
Another aspect of static analysis tools that may have hindered their application
to maintainability, is that they are predominantly rule-based. Since there has
not yet been a consensus on how to formalize maintainability, it is challenging
to devise a set of formal rules to detect it.

We designed our new tool Aibolit to help developers identify patterns in their
code  that may cause maintainability issues. It is a next generation static
analysis tool that uses a machine learning (ML) model as an underlying quality
prediction mechanism. From the perspective of ML, our product is a recommender
system. For a given class file, it gives suggestions to the developer to alter
their code. The recommendations come in the form of \textit{code patterns} that
are detected in the code and advised to be removed.

Our choice to design Aibolit as a ML-based system alleviates some important
shortcomings of rule-based static analyzers. By design, ML algorithms capture
statistical relations in the external world (data). Therefore, they can be a
good way to model imprecisely and subjectively defined properties of code, such
as its maintainability. Moreover, rule-based system are known to not scale well
to the diversity of empirically observed cases, and they tend to get very hard
to extend and maintain \citep{LenatFeigenbaum1987}. The ML
approach does not require
manual system adaptation as new observations or new features (patterns) come
along. In fact, Aibolit provides an easy way for developers to integrate a code
pattern of their liking into the recommender system and to analyze the pattern`s
impact on code quality.