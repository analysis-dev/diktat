Before we will move one, it is necessary to define some terms so that the reader correctly understands the context of what was written. 
The first and basic concept that should be introduced is \textbf{Rule} (marked with $R_i$). Rule in diKTat - is the logic described in a special class named with \texttt{"Rule"} suffix, which checks that a code is compliant with a certain paragraph of code-style. From the basics of maths you should know that the set - is a well-defined collection of distinct objects, considered as an object in its own right. So we can define a \textbf{Ruleset} - a set of such code analysis Rules. We will mark any of such set of Rules with $R$.

\textbf{Inspection} - is the part of any Rule. It is an algorithm that can detect (marked with $W_i$) or fix (marked with $F_i$) invalid code. It is very important to understand that $Rule \neq Inspection$. We will use $I_i$ notation to mark each separate inspection. So it is obvious that: $I_{ij} = \bigcup\limits_{i, j} W_{i} \cup F_{j}$, where $i, j \in \mathbb {N}$. Using the same logic we can say that $R = \bigcup\limits_{i} R_i$ where $R_i = \bigcup\limits_{i} I_i$.

\textbf{Abstract syntax tree (AST)} is a tree representation of the abstract syntactic structure of source code written in a programming language (Kotlin in our case). Each node of the tree denotes a construct occurring in the source code. \textbf{CI/CD} - continuous integration (CI) and continuous delivery (CD) is a methodology that allows application development teams to make changes to code more frequently and reliably \cite{ref:cicd}. \textbf{KDoc} - is the language used to document Kotlin code (the equivalent of Java's JavaDoc).